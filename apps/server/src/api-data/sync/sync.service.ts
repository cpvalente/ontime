import { WebSocket } from 'ws';
import { setSyncHost } from '../../services/app-state-service/AppStateService.js';
import { generateId } from 'ontime-utils';
import {
  Client,
  CustomFields,
  DatabaseModel,
  MessageTag,
  RefetchKey,
  Rundown,
  RuntimeStore,
  SyncClientList,
  SyncRoll,
  WsPacketToClient,
  WsPacketToServer,
} from 'ontime-types';
import { logger } from '../../classes/Logger.js';
import { shouldCrashDev } from '../../utils/development.js';
import { getDataProvider } from '../../classes/data-provider/DataProvider.js';
import { createProjectWithPatch, getCurrentProject } from '../../services/project-service/ProjectService.js';
import { getCurrentRundown, rundownCache, getProjectCustomFields } from '../rundown/rundown.dao.js';
import { loadRundown } from '../rundown/rundown.service.js';
import { sendRefetch } from '../../adapters/WebsocketAdapter.js';
import { RestorePoint } from '../../services/restore-service/restore.type.js';
import { restoreService } from '../../services/restore-service/restore.service.js';
import { runtimeService } from '../../services/runtime-service/runtime.service.js';
import getRandomName from '../../utils/getRandomName.js';
import { isSyncHost } from '../../setup/environment.js';
import { RuntimeState } from '../../stores/runtimeState.js';
import * as runtimeState from '../../stores/runtimeState.js';
import { eventStore } from '../../stores/EventStore.js';
import { dispatchFromAdapter } from '../../api-integration/integration.controller.js';
/**
 * Host: a server that waits with an open websocket
 * Client: a server that reaches out and connects to another servers websocket
 * Controller: a server that is in charge of the session
 * Listener: a server that listens to updates in the session
 */

const SYNC = 'SYNC';

enum SyncTag {
  List = 'sync-list',
  Roll = 'sync-roll',
  RefetchData = 'sync-refetch-data',
  RuntimeData = 'sync-runtime-data',
  Api = 'sync-api',
}

type ClientListPacket = { tag: SyncTag.List; payload: SyncClientList };
type ClientRollPacket = { tag: SyncTag.Roll; payload: { id: string; roll: SyncRoll } };

type RefetchDataPacket = {
  tag: SyncTag.RefetchData;
  payload:
    | {
        tag: RefetchKey.All;
        data: DatabaseModel;
        filename: string;
        currentRundown: string;
        restorePoint: RestorePoint | null;
      }
    | { tag: RefetchKey.Rundown; data: { rundown: Rundown; customFields: CustomFields } }
    | { tag: RefetchKey.CustomFields; data: { rundown: Rundown; customFields: CustomFields } }
    | { tag: RefetchKey.RestorePoint; data: RestorePoint | null };
};

type RuntimeDataPacket = { tag: SyncTag.RuntimeData; payload: Readonly<RuntimeState> };

type ApiDataPacket = { tag: SyncTag.Api; payload: { tag: string; payload: unknown } };

type SyncMessage =
  | ApiDataPacket
  | ClientListPacket
  | ClientRollPacket
  | RefetchDataPacket
  | RuntimeDataPacket
  | Extract<WsPacketToClient, { tag: MessageTag.RuntimeData }>
  | Extract<WsPacketToClient, { tag: MessageTag.ClientInit }>
  | Extract<WsPacketToServer, { tag: MessageTag.ClientSet }>;

type InternalSyncClient = { name: string; roll: SyncRoll; ws: WebSocket };

// TEST PACKAGES
// {
//     "tag": "client-set",
//     "payload": {
//         "name": "postman",
//         "type": "sync"
//     }
// }
// {
//     "tag": "session-roll",
//     "payload": "3a9884",
//     "roll": "controller"
// }

abstract class SyncService {
  protected roll = SyncRoll.Controller;

  protected id = generateId();
  protected name = getRandomName();
  protected dataProvider = getDataProvider();
  protected clientList: SyncClientList = [];
  // protected clientList: SyncClientList = [{ name: this.name, id: this.id, roll: SyncRoll.Unknown, host: null }];
  protected syncRuntimeStore = eventStore.poll();
  protected switchRoll(newRoll: SyncRoll) {
    logger.info(SYNC, `Switching roll to [${newRoll}]`);
    this.roll = newRoll;
    eventStore.set('sync', { roll: this.roll });
  }

  /**
   * Get the list of all connected to this sync session, is generated by the hosting server
   */
  public getClientList() {
    return this.clientList;
  }

  /**
   * get the roll of this server
   */
  public isListening() {
    return this.roll === SyncRoll.Listener;
  }

  /**
   * get the runtime sore distributed by this sync session
   */
  public getRuntimeStore() {
    return this.syncRuntimeStore;
  }

  public abstract forwardIntegrationRequests(tag: string, payload: unknown): void;

  /**
   * take over a ws connection
   * only available in host mode
   */
  public handleIncomingWsConnection(ws: WebSocket, _id: string, _clientInfo: Client): boolean {
    logger.warning(SYNC, 'received a connection request but this server dose not support that');
    ws.close();
    return false;
  }

  /**
   * connect to a sync host
   * not available in host mode
   */
  public async connect(_host: string, _roll: SyncRoll): Promise<boolean> {
    throw new Error('Can not connect to another host if already designated as host');
  }

  /**
   * connect to a sync host
   * not available in host mode
   */
  public async disconnect(): Promise<void> {
    throw new Error('Can not disconnect from a host if already designated as host');
  }

  /**
   * propagate refetch messages
   */
  public handleRefetch(_target: RefetchKey) {
    //TODO:
  }

  /**
   * propagate runtime state updates
   */
  public handleRuntimeStateUpdate(_state: Readonly<RuntimeState>) {
    //TODO:
  }

  public handleRuntimeStoreUpdate(_state: Readonly<RuntimeStore>) {
    //TODO:
  }

  protected async generateRefetchData(tag: RefetchKey): Promise<RefetchDataPacket['payload'] | undefined> {
    // if (this.roll !== SyncRoll.Controller) return;
    console.log('sending refetch', tag);

    switch (tag) {
      case RefetchKey.All:
        return {
          tag,
          data: this.dataProvider.getData(),
          filename: (await getCurrentProject()).filename,
          currentRundown: getCurrentRundown().id,
          restorePoint: restoreService.get(),
        };
      case RefetchKey.CustomFields:
      case RefetchKey.Rundown:
        return { tag, data: { rundown: getCurrentRundown(), customFields: getProjectCustomFields() } };
      case RefetchKey.RestorePoint:
        return { tag, data: restoreService.get() };
      default:
        //@ts-expect-error - FIXME: should be remove before release
        tag satisfies never;
        break;
    }
  }

  protected async receiveRefetchData(packet: RefetchDataPacket['payload']) {
    if (this.roll !== SyncRoll.Listener) {
      logger.warning(SYNC, 'received a data packet while not in Listener mode');
      return;
    }
    console.log('receiving refetch', packet.tag);

    switch (packet.tag) {
      case RefetchKey.All: {
        const { data, filename, currentRundown, restorePoint } = packet;
        // ensure we don't change the server port
        data.settings = { ...data.settings, serverPort: this.dataProvider.getSettings().serverPort };
        await createProjectWithPatch(`[SYNC]${filename}`, data);
        await loadRundown(currentRundown);
        runtimeService.init(restorePoint);
        break;
      }
      case RefetchKey.CustomFields:
      case RefetchKey.Rundown: {
        const { rundown, customFields } = packet.data;
        rundownCache.init(rundown, customFields);
        setImmediate(() => {
          sendRefetch(RefetchKey.Rundown, rundown.revision);
          sendRefetch(RefetchKey.CustomFields, rundown.revision);
        });
        break;
      }
      case RefetchKey.RestorePoint:
        runtimeService.init(packet.data);
        break;
      default:
        //@ts-expect-error - FIXME: should be remove before release
        packet.tag satisfies never;
        break;
    }
  }

  protected receiveRuntimeStoreData(packet: Partial<RuntimeStore>) {
    if (this.roll !== SyncRoll.Listener) {
      logger.warning(SYNC, 'received a data packet while not in Listener mode');
      return;
    }
    // drop the sync data as we want that to come from inside the server
    const { sync: _sync, ...rest } = packet;
    eventStore.createPatch(rest);
  }

  // protected receiveRuntimeStateData(packet: Partial<RuntimeState>) {
  //   if (this.roll !== SyncRoll.Listener) {
  //     logger.warning(SYNC, 'received a data packet while not in Listener mode');
  //     return;
  //   }
  //   this.syncRuntimeStore = { ...this.syncRuntimeStore, ...packet };
  // }

  /**
   * send a message to a specific ws socket
   */
  protected sendToSpecificSocket<T extends MessageTag | SyncTag>(
    ws: WebSocket | null,
    tag: T,
    payload: Pick<SyncMessage & { tag: T }, 'payload'>['payload'],
  ) {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    try {
      const stringifiedMessage = JSON.stringify({ tag, payload });
      ws.send(stringifiedMessage);
    } catch (_) {
      /** We do not handle this error */
    }
  }
}

class SyncServiceClient extends SyncService {
  private host: URL | null = null;
  private ws: null | WebSocket = null;

  public forwardIntegrationRequests(tag: string, payload: unknown): void {
    this.sendToSpecificSocket(this.ws, SyncTag.Api, { tag, payload });
  }

  async connect(host: string, roll: SyncRoll): Promise<boolean> {
    const healthCheckUrl = new URL(host);
    healthCheckUrl.pathname += 'health';
    const responds = await fetch(healthCheckUrl, { method: 'GET', headers: { 'x-ontime-client': 'server' } });
    if (!responds.ok) {
      throw new Error('Failed to helthcheck host server');
    }

    await setSyncHost(host);
    this.host = new URL(host);
    const wsUrl = new URL('ws', this.host);
    this.ws?.close();
    this.ws = new WebSocket(wsUrl);

    this.ws.once('open', async () => {
      logger.info(SYNC, 'connected to host');
      this.sendToSpecificSocket(this.ws, MessageTag.ClientSet, { name: this.name, type: 'sync' });
      this.roll = roll;
    });

    this.ws.once('close', async () => {
      logger.info(SYNC, 'host disconnected, switching to controller mode');
      this.switchRoll(SyncRoll.Controller);
    });

    this.ws.on('message', async (data) => {
      const msg = JSON.parse(data.toString()) as SyncMessage;
      const { tag, payload } = msg;

      switch (tag) {
        case SyncTag.List: {
          this.clientList = payload;
          const me = payload.find(({ id }) => id === this.id);
          if (!me) {
            throw new Error('This is missing from client list');
          }
          this.switchRoll(me.roll);
          break;
        }
        case MessageTag.ClientInit:
          this.id = payload.clientId;
          this.sendToSpecificSocket(this.ws, SyncTag.Roll, { id: this.id, roll });
          break;
        case MessageTag.RuntimeData:
          this.receiveRuntimeStoreData(payload);
          break;
        case SyncTag.RefetchData:
          await this.receiveRefetchData(payload);
          break;
        case SyncTag.RuntimeData:
          // this.receiveRuntimeStateData(payload);
          break;
        default:
          tag satisfies never | MessageTag.ClientSet | MessageTag.Refetch | SyncTag.Roll;
          break;
      }
    });
    return true;
  }
}

class SyncServiceHost extends SyncService {
  private clients = new Map<string, InternalSyncClient>();

  public forwardIntegrationRequests(tag: string, payload: unknown): void {
    this.propagateMessage(this.id, SyncTag.Api, { tag, payload });
  }

  public async handleRefetch(key: RefetchKey): Promise<void> {
    if (this.isListening()) return;
    const refetchMessage = await this.generateRefetchData(key);
    if (!refetchMessage) return;
    this.propagateMessage(this.id, SyncTag.RefetchData, refetchMessage);
  }

  /**
   * propagate runtime state updates
   */
  public handleRuntimeStateUpdate(_state: Readonly<RuntimeState>) {
    if (this.isListening()) return;
    this.propagateMessage(this.id, SyncTag.RuntimeData, runtimeState.getState());
  }

  /**
   * Host specific function, takes over the ws connections form the adaptor
   */
  handleIncomingWsConnection(ws: WebSocket, id: string, clientInfo: Client) {
    this.clients.set(id, { name: clientInfo.name, roll: SyncRoll.Unknown, ws });
    logger.info(SYNC, `client [${id}]${clientInfo.name} joined`);
    // this.sendToSpecificSocket(ws, SyncTag.Connected, { id });
    this.propagateMessage(this.id, SyncTag.List, this.generateClientList());

    ws.on('message', async (data) => {
      const msg = JSON.parse(data.toString()) as SyncMessage;
      const { tag, payload } = msg;
      switch (tag) {
        case SyncTag.Roll: {
          const { id: selectedId, roll } = payload;
          const selectedClient = this.clients.get(selectedId);
          if (roll === SyncRoll.Controller) {
            throw new Error('TODO: handle SyncRoll.Controller');
            // for (const [id, client] of clients) {
            //   if (id === newControllerId) {
            //     clients.set(id, { ...client, roll: SyncRoll.Controller });
            //   } else {
            //     clients.set(id, { ...client, roll: SyncRoll.Listener });
            //   }
            // }
          } else if (roll === SyncRoll.Listener && selectedClient?.roll === SyncRoll.Unknown) {
            logger.info(
              SYNC,
              `client [${id}]${clientInfo.name} switched from [${selectedClient.roll}] to [${SyncRoll.Listener}]`,
            );

            this.clients.set(selectedId, { ...selectedClient, roll: SyncRoll.Listener });
            this.propagateMessage(this.id, SyncTag.List, this.generateClientList());

            this.propagateMessage(this.id, SyncTag.RuntimeData, runtimeState.getState());
            const refetchMessage = await this.generateRefetchData(RefetchKey.All);
            if (!refetchMessage) throw new Error('Failed to generate refetch message');
            this.sendToSpecificSocket(selectedClient.ws, SyncTag.RefetchData, refetchMessage);
          }
          break;
        }
        case SyncTag.Api:
          dispatchFromAdapter(payload.tag, payload.payload);
          break;
        default: {
          //@ts-expect-error - FIXME: should be remove before release
          tag satisfies never;
        }
      }
    });

    ws.on('close', () => {
      const client = this.clients.get(id);
      if (!client) {
        logger.error(SYNC, `client [${id}]should exist`);
        this.clients.delete(id);
        return;
      }
      if (client.roll === SyncRoll.Controller) {
        logger.warning(SYNC, `controlling client [${id}]${client.name} disconnected, NOW WHAT?`);
      } else {
        logger.info(SYNC, `client [${id}]${client.name} disconnected`);
      }
      this.clients.delete(id);
    });

    return true;
  }

  /**
   * generate a list of all connected clients
   */
  private generateClientList = (): SyncClientList => {
    const c = Array.from(
      this.clients.entries().map(([id, { roll, name }]) => {
        return { id, roll, name, host: this.id };
      }),
    );
    c.push({ id: this.id, roll: this.roll, name: this.name, host: this.id });
    return c;
  };

  /**
   * Propagate messages to all connected clients
   */
  private propagateMessage<T extends MessageTag | SyncTag>(
    srcId: string,
    tag: T,
    payload: Pick<SyncMessage & { tag: T }, 'payload'>['payload'],
  ) {
    shouldCrashDev(!isSyncHost, 'is not session host');
    const senderRoll = srcId === this.id ? this.roll : this.clients.get(srcId)?.roll;
    if (senderRoll === SyncRoll.Controller) {
      const stringifiedMessage = JSON.stringify({ tag, payload });
      for (const [id, client] of this.clients) {
        if (id === srcId) continue;
        client.ws.send(stringifiedMessage);
      }
    }
  }
}

export const syncService: SyncService = isSyncHost ? new SyncServiceHost() : new SyncServiceClient();
